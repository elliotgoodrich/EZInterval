/******************************************************************//**
 * \file   interval.hpp
 * \author Elliot Goodrich
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *********************************************************************/

#ifndef INCLUDE_GUARD_97581AFD_D7FC_4A4A_9DAD_D0C5E1A7111C
#define INCLUDE_GUARD_97581AFD_D7FC_4A4A_9DAD_D0C5E1A7111C

#include "ez/direct_iterator.hpp"

#include <algorithm>
#include <cstddef>
#include <functional>
#include <iterator>
#include <limits>
#include <ostream>
#include <type_traits>
#include <stdexcept>
#include <utility>

namespace ez {

template <typename T, bool LOpen, bool ROpen>
class basic_interval;

namespace detail {

/* This struct will have type as an alias for the first non-void type in First, ...Rest. */
template <typename First, typename... Rest>
struct first_non_void {
	typedef First type;
};

template <typename...Rest>
struct first_non_void<void, Rest...> {
	typedef typename first_non_void<Rest...>::type type;
};

template <typename T, typename U>
bool lt_first_gt_second(std::pair<T, U> const& lhs, std::pair<T, U> const& rhs) {
	return (lhs.first == rhs.first) ? lhs.second > rhs.second : lhs.first < rhs.first;
}

template <typename T>
bool valid(T const& lower, T const& upper, bool left_open, bool right_open) {
	return (left_open || right_open) ? lower < upper : lower <= upper;
}

template <typename T>
T next_if_true(T value, bool b) {
	return b ? ++value : value;
}

template <typename L, bool LOpen>
class lower_bound {
	template <typename U>
	using common = typename std::common_type<L, U>::type;

public:
	lower_bound(L const& lower) noexcept(std::is_nothrow_copy_constructible<L>::value)
	: m_lower{lower} {
	}

	template <typename U>
	basic_interval<common<U>, LOpen, true> operator()(U const& upper) const {
		return {m_lower, upper};
	}

	template <typename U>
	basic_interval<common<U>, LOpen, false> operator[](U const& upper) const {
		return {m_lower, upper};
	}

private:
	L m_lower;
};

class interval_factory {
public:
	template <typename L>
	lower_bound<L, true> operator()(L const& lower) const {
		return {lower};
	}

	template <typename L>
	lower_bound<L, false> operator[](L const& lower) const {
		return {lower};
	}
};

}

/** An empty_interval exception is thrown when trying to construct an interval that is empty. */
struct empty_interval : public std::runtime_error {
public:
	empty_interval()
	: std::runtime_error{"Empty interval"} {
	}
};

/** A divide_by_zero exception is thrown when an interval is divided by zero or an interval
 *  that contains zero. */
struct divide_by_zero : std::runtime_error {
	divide_by_zero()
	: std::runtime_error{"Division by zero"} {
	}
};

template <typename T>
struct is_interval : std::false_type {
};

template <typename T>
struct is_nothrow_totally_ordered {
	static bool const value =
	  noexcept(std::declval<T&>() < std::declval<T&>()) &&
	  noexcept(std::declval<T&>() > std::declval<T&>()) &&
	  noexcept(std::declval<T&>() <= std::declval<T&>()) &&
	  noexcept(std::declval<T&>() >= std::declval<T&>()) &&
	  noexcept(std::declval<T&>() == std::declval<T&>()) &&
	  noexcept(std::declval<T&>() != std::declval<T&>());
};

/* These must be forward declared since they need to access a private constuctor of basic_interval
   in order to bypass it's check that the interval is valid. This check uses operator< which isn't
   defined for iterators that aren't random access iterators, though we know that the interval is
   valid if we create it directly from a container. */
template <typename Container>
basic_interval<typename Container::iterator, false, true> iterate(Container&);

template <typename Container>
basic_interval<typename Container::const_iterator, false, true> iterate(const Container&);

/** A class to represent a mathematical interval of type T where the openness can be changed at
 *  run-time. */
template <typename T, bool LOpen, bool ROpen>
class basic_interval {
public:
	typedef T type;
	typedef typename direct_iterator<T>::difference_type difference_type;

	basic_interval(T const& lower, T const& upper)
	: m_lower{lower}
	, m_upper{upper} {
		if(!detail::valid(m_lower, m_upper, LOpen, ROpen)) {
			throw empty_interval{};
		}
	}

	basic_interval(const basic_interval<T, LOpen, ROpen>&) = default;
	basic_interval(basic_interval<T, LOpen, ROpen>&&) = default;

	basic_interval<T, LOpen, ROpen>& operator=(const basic_interval<T, LOpen, ROpen>&) = default;
	basic_interval<T, LOpen, ROpen>& operator=(basic_interval<T, LOpen, ROpen>&&) = default;

	T const& lower() const noexcept {
		return m_lower;
	}

	T const& upper() const noexcept {
		return m_upper;
	}

	void assign(T const& lower, T const& upper) {
		if(!detail::valid(lower, upper, LOpen, ROpen)) {
			throw empty_interval{};
		}

		m_lower = lower;
		m_upper = upper;
	}

	bool left_open() const noexcept {
		return LOpen;
	}

	bool left_closed() const noexcept {
		return !LOpen;
	}

	bool right_open() const noexcept {
		return ROpen;
	}

	bool right_closed() const noexcept {
		return !ROpen;
	}

	direct_iterator<T> begin() const {
		return make_direct_iterator(detail::next_if_true(m_lower, left_open()));
	}

	direct_iterator<T> end() const {
		return make_direct_iterator(detail::next_if_true(m_upper, right_closed()));
	}

	direct_iterator<T> cbegin() const {
		return make_direct_iterator(detail::next_if_true(m_lower, left_open()));
	}

	direct_iterator<T> cend() const {
		return make_direct_iterator(detail::next_if_true(m_upper, right_closed()));
	}

private:
	template <typename Container>
	friend basic_interval<typename Container::iterator, false, true> iterate(Container&);

	template <typename Container>
	friend basic_interval<typename Container::const_iterator, false, true> iterate(const Container&);

	template <typename Container>
	basic_interval(const Container& c, std::nullptr_t)
	: m_lower{c.begin()}
	, m_upper{c.end()} {
		static_assert(!LOpen && ROpen, "");
	}

	template <typename Container>
	basic_interval(Container& c, std::nullptr_t)
	: m_lower{c.begin()}
	, m_upper{c.end()} {
		static_assert(!LOpen && ROpen, "");
	}

	T m_lower;
	T m_upper;
};

template <typename T, bool LOpen, bool ROpen>
struct is_interval<basic_interval<T, LOpen, ROpen>> : std::true_type {
};

/** Type alias for an open interval. */
template <typename T>
using open_interval = basic_interval<T, true, true>;

/** Type alias for a closed interval. */
template <typename T>
using closed_interval = basic_interval<T, false, false>;

/** Type alias for left open/right closed interval. */
template <typename T>
using lopen_interval = basic_interval<T, true, false>;

/** Type alias for left closed/right open interval. */
template <typename T>
using ropen_interval = basic_interval<T, false, true>;

/***************************************************************************************************
* Functions to help iterator over containers                                                       *
***************************************************************************************************/

template <typename Container>
basic_interval<typename Container::iterator, false, true> iterate(Container& c) {
	return {c, nullptr};
}

template <typename Container>
basic_interval<typename Container::const_iterator, false, true> iterate(const Container& c) {
	return {c, nullptr};
}

template <typename Container>
ropen_interval<typename Container::size_type> indices(const Container& c) {
	return {static_cast<typename Container::size_type>(0u), c.size()};
}

/***************************************************************************************************
* Compound assignment operators for basic_interval                                                 *
***************************************************************************************************/

template <typename T, bool LOpen, bool ROpen>
basic_interval<T, LOpen, ROpen>& operator+=(basic_interval<T, LOpen, ROpen>& l,
                                            basic_interval<T, LOpen, ROpen> const& r) {
	l.assign(l.lower() + r.lower(), l.upper() + r.upper());
	return l;
}

template <typename T, bool LOpen, bool ROpen>
basic_interval<T, LOpen, ROpen>&
  operator+=(basic_interval<T, LOpen, ROpen>& l,
             typename basic_interval<T, LOpen, ROpen>::difference_type const& d) {
	l.assign(l.lower() + d, l.upper() + d);
	return l;
}

template <typename T, bool LOpen, bool ROpen>
basic_interval<T, LOpen, ROpen> operator-=(basic_interval<T, LOpen, ROpen>& l,
                                           basic_interval<T, ROpen, LOpen> const& r) {
	l.assign(l.lower() - r.upper(), l.upper() - r.lower());
	return l;
}

template <typename T, bool LOpen, bool ROpen>
basic_interval<T, LOpen, ROpen>&
  operator-=(basic_interval<T, LOpen, ROpen>& l,
             typename basic_interval<T, LOpen, ROpen>::difference_type const& d) {
	l.assign(l.lower() - d, l.upper() - d);
	return l;
}

template <typename T, bool Open>
basic_interval<T, Open, Open>& operator*=(basic_interval<T, Open, Open>& l,
                                          basic_interval<T, Open, Open> const& r) {
	auto const result = std::minmax({l.lower() * r.lower(), l.lower() * r.upper(),
	                                 l.upper() * r.lower(), l.upper() * r.upper()});
	l.assign(result.first, result.second);
	return l;
}

template <typename T, bool LOpen, bool ROpen>
basic_interval<T, LOpen, ROpen>& operator*=(basic_interval<T, LOpen, ROpen>& l, T const& d) {
	l.assign(l.lower() * d, l.upper() * d);
	return l;
}

template <typename T, bool Open>
basic_interval<T, Open, Open>& operator/=(basic_interval<T, Open, Open>& l,
                                          basic_interval<T, Open, Open> const& r) {
	if(contains(r, 0)) {
		throw divide_by_zero{};
	}

	auto const result = std::minmax({l.lower() / r.lower(), l.lower() / r.upper(),
	                                 l.upper() / r.lower(), l.upper() / r.upper()});
	l.assign(result.first, result.second);
	return l;
}

template <typename T, bool LOpen, bool ROpen>
basic_interval<T, LOpen, ROpen>& operator/=(basic_interval<T, LOpen, ROpen>& l, T const& d) {
	if(d == T{0}) {
		throw divide_by_zero{};
	}

	l.assign(l.lower() / d, l.upper() / d);
	return l;
}

/***************************************************************************************************
* Arithmetic operators that return a basic_interval                                                *
***************************************************************************************************/

template <typename T, bool LOpen, bool ROpen>
basic_interval<T, LOpen, ROpen> operator+(basic_interval<T, LOpen, ROpen> l,
                                          basic_interval<T, LOpen, ROpen> const& r) {
	return l += r;
}

template <typename T, bool LOpen, bool ROpen>
basic_interval<T, LOpen, ROpen>
  operator+(basic_interval<T, LOpen, ROpen> l,
            typename basic_interval<T, LOpen, ROpen>::difference_type const& d) {
	return l += d;
}

template <typename T, bool LOpen, bool ROpen>
basic_interval<T, LOpen, ROpen>
  operator+(typename basic_interval<T, LOpen, ROpen>::difference_type const& d,
            basic_interval<T, LOpen, ROpen> l) {
	return l += d;
}

template <typename T, bool LOpen, bool ROpen>
basic_interval<T, LOpen, ROpen> operator-(basic_interval<T, LOpen, ROpen> l,
                                          basic_interval<T, ROpen, LOpen> const& r) {
	return l -= r;
}

template <typename T, bool LOpen, bool ROpen>
basic_interval<T, LOpen, ROpen>
  operator-(basic_interval<T, LOpen, ROpen> l,
            typename basic_interval<T, LOpen, ROpen>::difference_type const& d) {
	return l -= d;
}

template <typename T, bool LOpen, bool ROpen>
basic_interval<T, LOpen, ROpen>
  operator-(typename basic_interval<T, LOpen, ROpen>::difference_type const& d,
            basic_interval<T, LOpen, ROpen> l) {
	return l -= d;
}

template <typename T, bool Open>
basic_interval<T, Open, Open> operator*(basic_interval<T, Open, Open> l,
                                        basic_interval<T, Open, Open> const& r) {
	return l *= r;
}

template <typename T, bool LOpen, bool ROpen>
basic_interval<T, LOpen, ROpen> operator*(basic_interval<T, LOpen, ROpen> l, T const& d) {
	return l *= d;
}

template <typename T, bool LOpen, bool ROpen>
basic_interval<T, LOpen, ROpen> operator*(T const& d, basic_interval<T, LOpen, ROpen> l) {
	return l *= d;
}

template <typename T, bool Open>
basic_interval<T, Open, Open> operator/(basic_interval<T, Open, Open> l,
                                        basic_interval<T, Open, Open> const& r) {
	return l /= r;
}

template <typename T, bool LOpen, bool ROpen>
basic_interval<T, LOpen, ROpen> operator/(basic_interval<T, LOpen, ROpen> l, T const& d) {
	return l /= d;
}

/***************************************************************************************************
* interval class                                                                                   *
***************************************************************************************************/

typedef unsigned char openness_t;

enum openness : openness_t {
	closed     = 0x0,
	left_open  = 0x1,
	right_open = 0x2,
	open       = 0x3,
};

/** A class to represent a mathematical interval of type T where the openness can be changed at
 *  run-time.
 *
 *  The difference between this class and basic_interval<T, bool, bool> is that whether an
 *  interval is left-open or right-open is dynamic and not part of the type. This means that you
 *  can do things like finding the intersection of [a, b] and (c, d), where whether the result is
 *  left or right open is dependent on the values of a, b, c, and d at run-time.
 *
 *  \code
 *  interval<T> r = ez::make_interval[0](3); // construct from ez::make_interval
 *  interval<T> s{2, 3, ez::open};           // construct with ctor
 *  s.assign(s.lower(), 5);
 *  interval<T> t = union(r, s);
 *  std::cout << t << std::endl; // [0, 5]
 *  \endcode */
template <typename T>
class interval {
public:
	typedef T type;
	typedef typename direct_iterator<T>::difference_type difference_type;

	template <bool LOpen, bool ROpen>
	interval(basic_interval<T, LOpen, ROpen> const& r)
	: m_lower{r.lower()}
	, m_upper{r.upper()}
	, m_openness{static_cast<ez::openness>(LOpen * ez::left_open + ROpen * ez::right_open)} {
		if(!detail::valid(m_lower, m_upper, LOpen, ROpen)) {
			throw empty_interval{};
		}
	}

	interval(T const& lower, T const& upper, ez::openness o)
	: m_lower{lower}
	, m_upper{upper}
	, m_openness{o} {
		if(!detail::valid(m_lower, m_upper, left_open(), right_open())) {
			throw empty_interval{};
		}
	}

	interval(T const& lower, T const& upper, bool left_open, bool right_open)
	: m_lower{lower}
	, m_upper{upper}
	, m_openness{left_open ? (right_open ? ez::open : ez::left_open)
	                       : (right_open ? ez::right_open : ez::closed)} {
		if(!detail::valid(m_lower, m_upper, left_open, right_open)) {
			throw empty_interval{};
		}
	}

	interval(interval<T> const&) = default;
	interval(interval<T>&&) = default;

	template <bool LOpen, bool ROpen>
	interval<T>& operator=(basic_interval<T, LOpen, ROpen> const& r) {
		using std::swap;
		interval<T> copy{std::move(r)};
		swap(*this, copy);
		return *this;
	}

	interval<T>& operator=(interval<T> const&) = default;
	interval<T>& operator=(interval<T>&&) = default;

	T const& lower() const noexcept {
		return m_lower;
	}

	T const& upper() const noexcept {
		return m_upper;
	}

	void assign(T const& lower, T const& upper) {
		if(!detail::valid(m_lower, m_upper, left_open(), right_open())) {
			throw empty_interval{};
		}

		m_lower = lower;
		m_upper = upper;
	}

	void set_open(bool left_open, bool right_open) {
		if(!detail::valid(m_lower, m_upper, left_open, right_open)) {
			throw empty_interval{};
		}

		m_openness = static_cast<openness>(ez::left_open * left_open +
		                                   ez::right_open * right_open);
	}

	bool left_open() const noexcept {
		return m_openness & ez::left_open;
	}

	bool left_closed() const noexcept {
		return !left_open();
	}

	bool right_open() const noexcept {
		return m_openness & ez::right_open;
	}

	bool right_closed() const noexcept {
		return !right_open();
	}

	direct_iterator<T> begin() const {
		return make_direct_iterator(detail::next_if_true(m_lower, left_open()));
	}

	direct_iterator<T> end() const {
		return make_direct_iterator(detail::next_if_true(m_upper, right_closed()));
	}

	direct_iterator<T> cbegin() const {
		return make_direct_iterator(detail::next_if_true(m_lower, left_open()));
	}

	direct_iterator<T> cend() const {
		return make_direct_iterator(detail::next_if_true(m_upper, right_closed()));
	}

private:
	T m_lower;
	T m_upper;
	openness m_openness;
};

template <typename T>
struct is_interval<interval<T>> : std::true_type {
};

/***************************************************************************************************
* Compound assignment operators for interval                                                       *
***************************************************************************************************/

template <typename T, typename Interval>
interval<T>& operator+=(interval<T>& l, Interval const& r) {
	static_assert(std::is_same<T, typename Interval::type>::value,
	              "Underlying types of intervals must be equal");
	l.assign(l.lower() + r.lower(), l.upper() + r.upper());
	l.set_open(l.left_open() || r.left_open(), l.right_open() || r.right_open());
	return l;
}

template <typename T>
interval<T>& operator+=(interval<T>& l, typename interval<T>::difference_type const& d) {
	l.assign(l.lower() + d, l.upper() + d);
	return l;
}

template <typename T, typename Interval>
interval<T>& operator-=(interval<T>& l, Interval const& r) {
	l.assign(l.lower() - r.upper(), l.upper() - r.lower());
	l.set_open(l.left_open() || r.right_open(), l.right_open() || r.left_open());
	return l;
}

template <typename T>
interval<T>& operator-=(interval<T>& l, typename interval<T>::difference_type const& d) {
	l.assign(l.lower() - d, l.upper() - d);
	return l;
}

template <typename T>
interval<T>& operator*=(interval<T>& l, interval<T> const& r) {
	// We need to sort using the openness because if two values are equal, we want the one that
	// is closed and min(true, false) = false;
	auto const zero = T{0};
	auto const choices = {
	  std::make_pair(l.lower() * r.lower(), (l.left_open() && r.left_open())     ||
	                                        (l.left_open() && r.lower() != zero) ||
	                                        (r.left_open() && l.lower() != zero)),
	  std::make_pair(l.lower() * r.upper(), (l.left_open() && r.right_open())     ||
	                                        (l.left_open() && r.upper()  != zero) ||
	                                        (r.right_open() && l.lower() != zero)),
	  std::make_pair(l.upper() * r.lower(), (l.right_open() && r.left_open())     ||
	                                        (l.right_open() && r.lower() != zero) ||
	                                        (r.left_open()  && l.upper() != zero)),
	  std::make_pair(l.upper() * r.upper(), (l.right_open() && r.right_open())    ||
	                                        (l.right_open() && r.upper() != zero) ||
	                                        (r.right_open() && l.upper() != zero))
	};

	auto lower = std::min(choices);
	auto upper = std::max(choices, detail::lt_first_gt_second<T, bool>);

	l.assign(lower.first, upper.first);
	l.set_open(lower.second, upper.second);
	return l;
}

template <typename T, bool LOpen, bool ROpen>
interval<T>& operator*=(interval<T>& l, basic_interval<T, LOpen, ROpen> const& r) {
	return l *= ez::interval<T>{r};
}

template <typename T>
interval<T>& operator*=(interval<T>& l, T const& d) {
	l.assign(l.lower() * d, l.upper() * d);
	return l;
}

template <typename T>
interval<T>& operator/=(interval<T>& l, interval<T> const& r) {
	auto const zero = T{0};
	if(contains(make_closed(r), zero)) {
		throw ez::divide_by_zero{};
	}

	// We need to sort using the openness because if two values are equal, we want the one that
	// is closed and min(true, false) = false;
	auto const choices = {
	  std::make_pair(l.lower() / r.lower(), l.lower() != zero && (l.left_open() || r.left_open())),
	  std::make_pair(l.lower() / r.upper(), l.lower() != zero && (l.left_open() || r.right_open())),
	  std::make_pair(l.upper() / r.lower(), l.upper() != zero && (l.right_open() || r.left_open())),
	  std::make_pair(l.upper() / r.upper(), l.upper() != zero && (l.right_open() || r.right_open()))
	};

	auto const lower = std::min(choices);
	auto const upper = std::max(choices, detail::lt_first_gt_second<T, bool>);
	l.assign(lower.first, upper.first);
	l.set_open(lower.second, upper.second);
	return l;
}

template <typename T, bool LOpen, bool ROpen>
interval<T>& operator/=(interval<T>& l, basic_interval<T, LOpen, ROpen> const& r) {
	return l /= ez::interval<T>{r};
}

template <typename T>
interval<T>& operator/=(interval<T>& l, T const& d) {
	if(d == T{0}) {
		throw ez::divide_by_zero{};
	}

	l.assign(l.lower() / d, l.upper() / d);
	return l;
}

/***************************************************************************************************
* Arithmetic operators that return an interval                                                     *
***************************************************************************************************/

template <typename T>
interval<T> operator+(interval<T> l, interval<T> const& r) {
	return l += r;
}

template <typename T, bool LOpen, bool ROpen>
interval<T> operator+(interval<T> l, basic_interval<T, LOpen, ROpen> const& r) {
	return l += r;
}

template <typename T, bool LOpen, bool ROpen>
interval<T> operator+(basic_interval<T, LOpen, ROpen> const& l, interval<T> r) {
	return r += l;
}

template <typename T, bool LOpen1, bool ROpen1, bool LOpen2, bool ROpen2>
interval<T> operator+(basic_interval<T, LOpen1, ROpen1> l,
                      basic_interval<T, LOpen2, ROpen2> const& r) {
	interval<T> x{std::move(l)};
	return x += r;
}

template <typename T>
interval<T> operator+(interval<T> l, typename interval<T>::difference_type const& d) {
	return l += d;
}

template <typename T>
interval<T> operator+(typename interval<T>::difference_type const& d, interval<T> l) {
	return l += d;
}

template <typename T>
interval<T> operator-(interval<T> l, interval<T> const& r) {
	return l -= r;
}

template <typename T, bool LOpen, bool ROpen>
interval<T> operator-(interval<T> l, basic_interval<T, LOpen, ROpen> const& r) {
	return l -= r;
}

template <typename T, bool LOpen, bool ROpen>
interval<T> operator-(basic_interval<T, LOpen, ROpen> const& l, interval<T> r) {
	return r -= l;
}

template <typename T, bool LOpen1, bool ROpen1, bool LOpen2, bool ROpen2>
interval<T> operator-(basic_interval<T, LOpen1, ROpen1> l,
                      basic_interval<T, LOpen2, ROpen2> const& r) {
	interval<T> x{std::move(l)};
	return x -= r;
}

template <typename T>
interval<T> operator-(interval<T> l, typename interval<T>::difference_type const& d) {
	return l -= d;
}

template <typename T>
interval<T> operator*(interval<T> l, interval<T> const& r) {
	return l *= r;
}

template <typename T, bool LOpen, bool ROpen>
interval<T> operator*(interval<T> l, basic_interval<T, LOpen, ROpen> const& r) {
	return l *= r;
}

template <typename T, bool LOpen, bool ROpen>
interval<T> operator*(basic_interval<T, LOpen, ROpen> const& l, interval<T> const& r) {
	ez::interval<T> tmp = l;
	return tmp *= r;
}

template <typename T, bool LOpen1, bool ROpen1, bool LOpen2, bool ROpen2>
interval<T> operator*(basic_interval<T, LOpen1, ROpen1> const& l,
                      basic_interval<T, LOpen2, ROpen2> const& r) {
	ez::interval<T> tmp = l;
	return tmp *= r;
}

template <typename T>
interval<T> operator*(interval<T> l, typename interval<T>::difference_type const& d) {
	return l *= d;
}

template <typename T>
interval<T> operator*(typename interval<T>::difference_type const& d, interval<T> l) {
	return l *= d;
}

template <typename T>
interval<T> operator/(interval<T> l, interval<T> const& r) {
	return l /= r;
}

template <typename T, bool LOpen, bool ROpen>
interval<T> operator/(interval<T> l, basic_interval<T, LOpen, ROpen> const& r) {
	return l /= r;
}

template <typename T, bool LOpen, bool ROpen>
interval<T> operator/(basic_interval<T, LOpen, ROpen> const& l, interval<T> const& r) {
	ez::interval<T> tmp = l;
	return tmp /= r;
}

template <typename T, bool LOpen1, bool ROpen1, bool LOpen2, bool ROpen2>
interval<T> operator/(basic_interval<T, LOpen1, ROpen1> const& l,
                      basic_interval<T, LOpen2, ROpen2> const& r) {
	ez::interval<T> tmp = l;
	return tmp /= r;
}

template <typename T>
interval<T> operator/(interval<T> l, typename interval<T>::difference_type const& d) {
	return l /= d;
}

/***************************************************************************************************
* Functions which work on both interval and basic_interval                                         *
***************************************************************************************************/

template <typename Interval1, typename Interval2,
          typename std::enable_if<is_interval<Interval1>::value &&
                                  is_interval<Interval2>::value>::type* = nullptr>
bool operator==(Interval1 const& lhs, Interval2 const& rhs)
  noexcept(is_nothrow_totally_ordered<typename Interval1::type>::value) {
	static_assert(std::is_same<typename Interval1::type, typename Interval2::type>::value,
	              "Underlying types of intervals must be equal");
	return lhs.left_open()  == rhs.left_open()
	    && lhs.right_open() == rhs.right_open()
	    && lhs.lower()      == rhs.lower()
	    && lhs.upper()      == rhs.upper();
}

template <typename Interval1, typename Interval2,
          typename std::enable_if<is_interval<Interval1>::value &&
                                  is_interval<Interval2>::value>::type* = nullptr>
bool operator!=(Interval1 const& lhs, Interval2 const& rhs)
  noexcept(is_nothrow_totally_ordered<typename Interval1::type>::value) {
	return !(lhs == rhs);
}

/** Returns true if \a r contains only one element. */
template <typename Interval,
          typename std::enable_if<is_interval<Interval>::value>::type* = nullptr>
bool singleton(Interval const& r)
  noexcept(is_nothrow_totally_ordered<typename Interval::type>::value) {
	return r.left_closed() && r.right_closed() && (r.lower() == r.upper());
}

/** Converts an interval with underlying type To to an interval of underlying type From. */
template <typename To, typename From>
interval<To> interval_cast(interval<From> const& r) {
	return {static_cast<To>(r.lower()), static_cast<To>(r.upper()), r.left_open(), r.right_open()};
}

/** Converts a basic_interval with underlying type To to an interval of underlying type From. */
template <typename To, typename From, bool LOpen, bool ROpen>
basic_interval<To, LOpen, ROpen> interval_cast(basic_interval<From, LOpen, ROpen> const& r) {
	return {static_cast<To>(r.lower()), static_cast<To>(r.upper())};
}

/** Returns the difference between the upper and lower bounds of \a r. */
template <typename Interval, typename U = typename Interval::type,
          typename std::enable_if<is_interval<Interval>::value>::type* = nullptr>
U diameter(Interval const& r) {
	return static_cast<U>(r.upper()) - static_cast<U>(r.lower());
}

/** Returns the midpoint between the upper and lower bounds of \a r.
 *
 *  Pass an additional type if the underlying type of basic_interval is not appropriate. For
 *  example, if you have an interval of [0, 3]. Then midpoint<int> will give (3-0)/2 = 1, but
 *  midpoint<double> will give (3.0-1.0)/2 = 1.5.
 *
 *  \code
 *  auto r = ez::make_interval[0][1];
 *  auto a = ez::midpoint(r); // 0
 *  auto b = ez::midpoint<double>(r); // 0.5
 *  \endcode */
template <typename U = void, typename Interval,
          typename std::enable_if<is_interval<Interval>::value>::type* = nullptr,
          typename Return = typename detail::first_non_void<U, typename Interval::type>::type>
Return midpoint(Interval const& r) {
	return static_cast<Return>(r.lower()) +
	  (static_cast<Return>(r.upper()) - static_cast<Return>(r.lower())) / 2;
}

/** Returns half of the diameter of \a r.
 *
 *  Pass a different type if you are worried about rounding issues with the underlying type.
 *
 *  \code
 *  auto i = ez::make_interval[3][8];
 *  auto r = ez::radius(i); // 2
 *  auto s = ez::radius<double>(i); // 2.5
 *  \endcode */
template <typename U = void, typename Interval,
          typename std::enable_if<is_interval<Interval>::value>::type* = nullptr,
          typename Return = typename detail::first_non_void<U, typename Interval::type>::type>
Return radius(Interval const& r) {
	return static_cast<Return>(diameter(r)) / 2;
}

/** Returns true if \a value is within the interval \a r. */
template <typename Interval,
          typename std::enable_if<is_interval<Interval>::value>::type* = nullptr>
bool contains(Interval const& r, typename Interval::type const& value)
  noexcept(is_nothrow_totally_ordered<typename Interval::type>::value) {
	return (r.left_open()  ? r.lower() < value : r.lower() <= value) &&
	       (r.right_open() ? r.upper() > value : r.upper() >= value);
}

/** Converts an interval to closed
 *
 *  \code
 *  auto a = ez::interval<int>(0, 1, ez::open);
 *  auto b = make_closed(a); // b is now of type ez::closed_interval<int>
 *  \endcode */
template <typename Interval,
          typename std::enable_if<is_interval<Interval>::value>::type* = nullptr>
closed_interval<typename Interval::type> make_closed(Interval const& r) {
	return {r.lower(), r.upper()};
}

/** Converts an interval to open
 *
 *  \code
 *  auto a = ez::interval<int>(0, 1, ez::closed);
 *  auto b = make_open(a); // b is now of type ez::open_interval<int>
 *  \endcode */
template <typename Interval,
          typename std::enable_if<is_interval<Interval>::value>::type* = nullptr>
open_interval<typename Interval::type> make_open(Interval const& r) {
	return {r.lower(), r.upper()};
}

/** Serialise an interval \a r to a \a stream. */
template <typename T>
std::ostream& operator<<(std::ostream& stream, interval<T> const& r) {
	return stream << (r.left_open() ? "(" : "[")
	              << r.lower() << ", " << r.upper()
	              << (r.right_open() ? ")" : "]");
}

template <typename T, bool LOpen, bool ROpen>
std::ostream& operator<<(std::ostream& stream, basic_interval<T, LOpen, ROpen> const& r) {
	return stream << interval<T>{r};
}

/** Returns the interval intersection between \a lhs and \a rhs.
 *
 *  Note that the value type of Interval1 and Interval2 must be the same. This function returns an
 *  object of type interval<T> because the openness of the return value is dependent on the lower
 *  and upper bounds of both \a lhs and \a rhs.
 *
 *  If there is no intersection between \a lhs and \a rhs then this function will throw when
 *  constructing the return object.
 *
 *  \code
 *  auto a = ez::make_interval[-1][5];
 *  auto b = ez::make_interval(1)(6);
 *  assert(intersection(a, b) == ez::make_interval(1)[5]);
 *  \endcode */
template <typename Interval1, typename Interval2,
          typename std::enable_if<is_interval<Interval1>::value &&
                                  is_interval<Interval2>::value>::type* = nullptr>
interval<typename Interval1::type> intersection(Interval1 const& lhs,
                                                Interval2 const& rhs) {
	static_assert(std::is_same<typename Interval1::type, typename Interval2::type>::value,
	              "Underlying types of intervals must be equal");
	typedef typename Interval1::type T;

	auto const lower = std::max(std::make_pair(lhs.lower(), lhs.left_open()),
	                            std::make_pair(rhs.lower(), rhs.left_open()));
	auto const upper = std::min(std::make_pair(lhs.upper(), lhs.right_open()),
	                            std::make_pair(rhs.upper(), rhs.right_open()),
	                            detail::lt_first_gt_second<T, bool>);

	return {lower.first, upper.first, lower.second, upper.second};
}

/** Returns the interval intersection between \a lhs and \a rhs.
 *
 *  \code
 *  auto a = ez::make_interval[3](6);
 *  auto b = ez::make_interval[1](8);
 *  assert(intersection(a, b) == ez::make_interval[3](6));
 *  \endcode */
template <typename T, bool LOpen, bool ROpen>
basic_interval<T, LOpen, ROpen> intersection(basic_interval<T, LOpen, ROpen> const& lhs,
                                             basic_interval<T, LOpen, ROpen> const& rhs) {
	return {std::max(lhs.lower(), rhs.lower()), std::min(lhs.upper(), rhs.upper())};
}

/** Returns the smallest interval containing both \a lhs and \a rhs.
 *
 *  \code
 *  auto a = ez::make_interval[3][9];
 *  auto b = ez::make_interval(1)(8);
 *  assert(hull(a, b) == ez::make_interval(1)[9]);
 *  \endcode */
template <typename Interval1, typename Interval2,
          typename std::enable_if<is_interval<Interval1>::value &&
                                  is_interval<Interval2>::value>::type* = nullptr>
interval<typename Interval1::type> hull(Interval1 const& lhs, Interval2 const& rhs)
  noexcept(is_nothrow_totally_ordered<typename Interval1::type>::value) {
	static_assert(std::is_same<typename Interval1::type, typename Interval2::type>::value,
	              "Underlying types of intervals must be equal");
	typedef typename  Interval1::type T;

	auto const lower = std::min(std::make_pair(lhs.lower(), lhs.left_open()),
	                            std::make_pair(rhs.lower(), rhs.left_open()));
	auto const upper = std::max(std::make_pair(lhs.upper(), lhs.right_open()),
	                            std::make_pair(rhs.upper(), rhs.right_open()),
	                            detail::lt_first_gt_second<T, bool>);

	return {lower.first, upper.first, lower.second, upper.second};
}

/** Returns the smallest basic_interval containing both \a lhs and \a rhs. */
template <typename T, bool LOpen, bool ROpen>
basic_interval<T, LOpen, ROpen> hull(basic_interval<T, LOpen, ROpen> const& lhs,
                                     basic_interval<T, LOpen, ROpen> const& rhs)
  noexcept(is_nothrow_totally_ordered<T>::value) {
	return {std::min(lhs.lower(), rhs.lower()), std::max(lhs.upper(), rhs.upper())};
}

/** Returns true if \a is a subset of \a b. */
template <typename T>
bool subset(interval<T> const& a, interval<T> const& b)
  noexcept(is_nothrow_totally_ordered<T>::value) {
	auto const lower_strict_comp = a.left_open() || !b.left_open();
	auto const upper_strict_comp = a.right_open() || !b.right_open();

	return (lower_strict_comp ? b.lower() <= a.lower()
	                          : b.lower() < a.lower()) &&
	       (upper_strict_comp ? a.upper() <= b.upper()
	                          : a.upper() < b.upper());
}

/** Returns true if \a is a subset of \a b. */
template <typename T, bool LOpen1, bool ROpen1, bool LOpen2, bool ROpen2>
bool subset(basic_interval<T, LOpen1, ROpen1> const& a,
            basic_interval<T, LOpen2, ROpen2> const& b)
  noexcept(is_nothrow_totally_ordered<T>::value) {
	return subset(interval<T>{a}, interval<T>{b});
}

/** Returns true if \a is a superset of \a b. */
template <typename T>
bool superset(interval<T> const& a, interval<T> const& b)
  noexcept(is_nothrow_totally_ordered<T>::value) {
	return subset(b, a);
}

/** Returns true if \a is a superset of \a b. */
template <typename T, bool LOpen1, bool ROpen1, bool LOpen2, bool ROpen2>
bool superset(basic_interval<T, LOpen1, ROpen1> const& a,
              basic_interval<T, LOpen2, ROpen2> const& b)
  noexcept(is_nothrow_totally_ordered<T>::value) {
	return superset(interval<T>{a}, interval<T>{b});
}

/** Returns true if \a is a proper subset (\a is a subset but not equal to \a b) of \a b. */
template <typename T>
bool proper_subset(interval<T> const& a, interval<T> const& b)
  noexcept(is_nothrow_totally_ordered<T>::value) {
	auto const lower_strict_comp = a.left_open() && !b.left_open();
	auto const upper_strict_comp = a.right_open() && !b.right_open();

	return (lower_strict_comp ? b.lower() <= a.lower()
	                          : b.lower() < a.lower()) &&
	       (upper_strict_comp ? a.upper() <= b.upper()
	                          : a.upper() < b.upper());
}

/** Returns true if \a is a proper subset (\a is a subset but not equal to \a b) of \a b. */
template <typename T, bool LOpen1, bool ROpen1, bool LOpen2, bool ROpen2>
bool proper_subset(basic_interval<T, LOpen1, ROpen1> const& a,
                   basic_interval<T, LOpen2, ROpen2> const& b)
  noexcept(is_nothrow_totally_ordered<T>::value) {
	return proper_subset(interval<T>{a}, interval<T>{b});
}

/** Returns true if \a is a proper superset (\a is a superset but not equal to \a b) of \a b. */
template <typename T>
bool proper_superset(interval<T> const& a, interval<T> const& b)
  noexcept(is_nothrow_totally_ordered<T>::value) {
	return proper_subset(b, a);
}

/** Returns true if \a is a proper superset (\a is a superset but not equal to \a b) of \a b. */
template <typename T, bool LOpen1, bool ROpen1, bool LOpen2, bool ROpen2>
bool proper_superset(basic_interval<T, LOpen1, ROpen1> const& a,
                     basic_interval<T, LOpen2, ROpen2> const& b)
  noexcept(is_nothrow_totally_ordered<T>::value) {
	return proper_superset(interval<T>{a}, interval<T>{b});
}

/** Returns the interval that would be the codomain of applying an increasing function \a f to
 *  the interval \a r.
 *
 *  As \a f is not strictly increasing, this must return a closed function. */
template <typename Interval, typename MonotonicFunction,
          typename std::enable_if<is_interval<Interval>::value>::type* = nullptr>
closed_interval<typename Interval::type> apply_increasing(Interval const& r, MonotonicFunction f) {
	return {f(r.lower()), f(r.upper())};
}

/** Returns the interval that would be the codomain of applying a strictly increasing function \a f
 *  to the interval \a r. */
template <typename Interval, typename MonotonicFunction,
          typename std::enable_if<is_interval<Interval>::value>::type* = nullptr>
Interval apply_strictly_increasing(Interval const& r, MonotonicFunction f) {
	return {f(r.lower()), f(r.upper())};
}

/** Returns the interval that would be the codomain of applying an decreasing function \a f to
 *  the interval \a r.
 *
 *  As \a f is not strictly decreasing, this must return a closed function. */
template <typename Interval, typename MonotonicFunction,
          typename std::enable_if<is_interval<Interval>::value>::type* = nullptr>
closed_interval<typename Interval::type> apply_decreasing(Interval const& r, MonotonicFunction f) {
	return {f(r.upper()), f(r.lower())};
}

/** Returns the interval that would be the codomain of applying a strictly decreasing function \a f
 *  to the interval \a r. */
template <typename Interval, typename MonotonicFunction,
          typename std::enable_if<is_interval<Interval>::value>::type* = nullptr>
Interval apply_strictly_decreasing(Interval const& r, MonotonicFunction f) {
	return {f(r.upper()), f(r.lower())};
}

/** This variable is used to create intervals by calling the index array operator and function
 *  operator.

 *  \code
 *  auto a = ez::make_interval[0][1];  // Returns ez::closed_interval<int>
 *  auto b = ez::make_interval[2](3);  // Returns ez::right_open<int>
 *  auto c = ez::make_interval(4)[8];  // Returns ez::left_open<int>
 *  auto d = ez::make_interval(-1)(1); // Returns ez::open_interval<int>
 *  \endcode */
static detail::interval_factory const make_interval;

}

#endif
